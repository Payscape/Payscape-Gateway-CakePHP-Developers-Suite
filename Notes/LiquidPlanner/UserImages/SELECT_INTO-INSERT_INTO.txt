
SELECT INTO - creates a new table from the query
INSERT INTO - used to populate a table that already exists


SQL Select Into Field 

up vote 3 down vote favorite I want to accomplish something of the 
following: 

Select DISTINCT(tableA.column) INTO tableB.column FROM tableA The goal 
would be to select a distinct data set and then insert that data into a 
specific column of a new table. 



You're pretty much there. 

SELECT DISTINCT column INTO tableB FROM tableA It's going to insert into 
whatever column(s) are specified in the select list, so you would need 
to alias your select values if you need to insert into columns of tableB 
that aren't in tableA. 

SELECT INTO 


SELECT column INTO tableB FROM tableA 

SELECT INTO 
will create a table as it inserts new records into it. 

If that is not what you want (if tableB already exists), then you will need to do 
something like this: 

INSERT INTO tableB ( column ) SELECT DISTINCT column FROM tableA 
Remember that if tableb has more columns that just the one, you will 
need to list the columns you will be inserted into (like I have done in 
my example). 

INSERT INTO tableB (column) Select DISTINCT(tableA.column) FROM tableA 

The goal would be to select a distinct data set and 
then insert that data into a specific column of a new table. I don't 
know what the schema of tableB is... if table B already exists and there 
is no unique constraint on the column you can do as any of the others 
suggest here.... 

INSERT INTO tableB (column)Select DISTINCT(tableA.column)FROM tableA 

but if you have a unique constraint on table B and it already exists 
you'll have to exclude those values already in table B... 

INSERT INTO tableB (column) Select DISTINCT(tableA.column) FROM tableA 
WHERE tableA.column NOT IN (SELECT /* NOTE */ tableB.column FROM tableB) 
-- NOTE: Remember if there is a unique constraint you don't need the 
more -- costly form of a "SELECT DISTICT" in this subquery against 
tableB -- This could be done in a number of different ways - this is 
just -- one version. Best version will depend on size of data in each 
table, -- indexes available, etc. Always prototype different ways and 
measure perf. 


